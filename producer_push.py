import logging
import os
import sys
import time
import json
import random

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

#ezeket olvashatná egy config fájlból
endpoint = "tcp://127.0.0.1:5555"
endpoint_ip = '127.0.0.1'
SERIAL_NUM = 414516
MAX_BUFFER = 10

#itt legenerálni a cliens saját kulcsot a server public kulccsal

# These directories are generated by the generate_certificates script
base_dir = os.path.dirname(__file__)
keys_dir = os.path.join(base_dir, 'certificates')
public_keys_dir = os.path.join(base_dir, 'public_keys')
secret_keys_dir = os.path.join(base_dir, 'private_keys')

if not (os.path.exists(keys_dir) and
        os.path.exists(public_keys_dir) and
        os.path.exists(secret_keys_dir)):
    print("Certificates are missing: run generate_certificates.py script first")
    sys.exit(1)
try:
    ctx = zmq.Context.instance()

    # Start an authenticator for this context.
    auth = ThreadAuthenticator(ctx)
    auth.start()
    auth.allow(endpoint_ip)
    # Tell the authenticator how to handle CURVE requests
    auth.configure_curve(domain='*', location=zmq.auth.CURVE_ALLOW_ANY)

    client = ctx.socket(zmq.REQ)
    # recv-vel vár és timeoutolni, hogy ha nem válaszol, akkor el kell tárolni

    # We need two certificates, one for the client and one for
    # the server. The client must know the server's public key
    # to make a CURVE connection.
    client_secret_file = os.path.join(secret_keys_dir, "client.key_secret")
    client_public, client_secret = zmq.auth.load_certificate(client_secret_file)
    client.curve_secretkey = client_secret
    client.curve_publickey = client_public

    # The client must know the server's public key to make a CURVE connection.
    server_public_file = os.path.join(public_keys_dir, "server.key")
    server_public, _ = zmq.auth.load_certificate(server_public_file)
    client.curve_serverkey = server_public

    client.connect(endpoint)
    print("bound to zmq endpoint", endpoint)

except:
    print("creating zmq context/authentication failed")
    quit()


poller = zmq.Poller()
poller.register(client, zmq.POLLIN)  # POLLIN for recv, POLLOUT for send
packed = {'measures': []}

try:
    while True:
        time.sleep(2.2)
        systolic_pres = random.randint(90, 140)
        diastolic_pres = random.randint(60, 90)
        # vagy zmq szintű vagy alkalmazás szintű kezelése a nyugtázásnak
        # zmq - van saját buffere (mj: zmq_noblock flag)
        # lehet alkalmazás szintű is az ACK
        packed['measures'].append({
            'serial_num': SERIAL_NUM,
            'buffer_pos': len(packed['measures'])+1,
            'systolic_pres': systolic_pres,
            'diastolic_pres': diastolic_pres,
            'time': time.localtime()  # ??timestamp
        })

        sent = False
        try:
            print("Sending %d message(s) from buffer: " % len(packed['measures']), packed)
            client.send_json(packed)
            print("sent package: ", packed['measures'])
            sent = True
        except:
            print("error sending message")
            if len(packed['measures']) >= MAX_BUFFER:
                print('- buffer maxed out (%d item)\n- dropping oldest measure (%d already dropped)' % (MAX_BUFFER, packed['measures'][0]['buffer_pos']-1))
                packed['measures'].pop(0)
            try:
                print("reconnecting server...")
                client.disconnect(endpoint)
                client.connect(endpoint)
                print("bound to zmq endpoint", endpoint)
            except:
                print("server unreachable")

        if sent:
            arrived = False

            socks = dict(poller.poll(2000))  # POLL socket for 2000ms
            if client in socks:
                try:
                    last_received_id = client.recv()
                    if int(last_received_id) == len(packed['measures']):
                        arrived = True
                except:
                    print("error reading respond message to #%d" % packed['measures'][len(packed['measures'])-1]['buffer_pos'])

            if arrived:
                print('Server received: #%d measure from %d sensor buffer' % (packed['measures'][len(packed['measures'])-1]['buffer_pos'], packed['measures'][len(packed['measures'])-1]['serial_num']))
                packed = {'measures': []}
            else:
                print('Server DID NOT received: #%d measure from %d sensor buffer' % (packed['measures'][len(packed['measures'])-1]['buffer_pos'], packed['measures'][len(packed['measures'])-1]['serial_num']), arrived)
                if len(packed['measures']) >= MAX_BUFFER:
                    packed['measures'].pop(0)


except KeyboardInterrupt:
    print('Stopping client...')
    # stop auth thread
    auth.stop()
