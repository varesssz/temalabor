import logging
import os
import sys
import signal
import time
import json

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

endpoint = "tcp://127.0.0.1:5555"
endpoint_ip = '127.0.0.1'


# These directories are generated by the generate_certificates script
base_dir = os.path.dirname(__file__)
keys_dir = os.path.join(base_dir, 'certificates')
public_keys_dir = os.path.join(base_dir, 'public_keys')
secret_keys_dir = os.path.join(base_dir, 'private_keys')

if not (os.path.exists(keys_dir) and
        os.path.exists(public_keys_dir) and
        os.path.exists(secret_keys_dir)):
    print("Certificates are missing: run generate_certificates.py script first")
    sys.exit(1)

try:
    ctx = zmq.Context.instance()

    # Start an authenticator for this context.
    auth = ThreadAuthenticator(ctx)
    auth.start()
    auth.allow(endpoint_ip)
    # Tell the authenticator how to handle CURVE requests
    auth.configure_curve(domain='*', location=zmq.auth.CURVE_ALLOW_ANY)

    server = ctx.socket(zmq.REP)
    # ötlet: lecserélni REQ-REPra, itt a szerver tud választ adni pl ha timeouttal nem jön üzenet
    # küldésre várni valami ackot és a poller vár timeoutig
    # , hogy alkalmazási rétegen is lehessen látni a kapcsolatot ezért kell ellenőrzés
    # collector válaszra érkezhet új üzenet
    # recv-vel vár ez a REP, ha megjött, eltárolja SQL-be, senddel küld egy választ azon a socketen
    server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
    server_public, server_secret = zmq.auth.load_certificate(server_secret_file)
    server.curve_secretkey = server_secret
    server.curve_publickey = server_public
    server.curve_server = True  # must come before bind
    server.bind(endpoint)

    poller = zmq.Poller()
    poller.register(server, zmq.POLLIN)

except:
    print("creating zmq context/authentication failed")

try:
    while True:
        try:
            socks = dict(poller.poll(2500))  # POLL socket for 2000ms
        except KeyboardInterrupt:
            break;
        got_msg = False
        if server in socks:
            try:
                msg = server.recv_json() # socket reading
                got_msg = True
            except:
                print("error reading message")

        if got_msg:
            # printing all the values from one received json
            last_received = 0
            for m in msg['measures']:
                print('Sensor Serial: ', m['serial_num'])
                print('Measure position form buffer: ', m['buffer_pos'])
                print('Measured Systolic Pressure: %d Hgmm'
                      % m['systolic_pres'])
                print('Measured Diastolic Pressure: %d Hgmm'
                      % m['diastolic_pres'])
                print('Timestamp: %d.%02d.%02d - %02d:%02d:%02d'
                      % (m['time'][0], m['time'][1], m['time'][2], m['time'][3], m['time'][4], m['time'][5]))
                print('')

                last_received = m['buffer_pos']
                # jó lenne: egy mysql connectorral adatbázisba egy egyszerű sémával tárolni is ezeket
                # egy egyszerű lekérdezést is lehet a bemutatónál a mysqlben, nem a kódban (az lehet továbbfejlesztés)
                # pl X dokihoz tartotó 3 X serialú eszköz, utolsó 20 adat átlaga

            #respond
            server.send(b'%d' % last_received)

        else:
            print("no message received in this turn")


except KeyboardInterrupt:
    print('Stopping client...')
    # stop auth thread
    auth.stop()
