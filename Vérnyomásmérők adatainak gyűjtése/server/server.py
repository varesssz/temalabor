import logging
import os
import sys
import signal
import time
import datetime
import json
import mysql.connector

import zmq
import zmq.auth
from zmq.auth.thread import ThreadAuthenticator

'''Konfigurációs adatok'''
endpoint = "tcp://127.0.0.1:5555"
endpoint_ip = '127.0.0.1'

# These directories are generated by the generate_certificates script
base_dir = os.path.dirname(__file__)
keys_dir = os.path.join(base_dir, 'certificates')
public_keys_dir = os.path.join(base_dir, 'public_keys')
secret_keys_dir = os.path.join(base_dir, 'private_keys')

if not (os.path.exists(keys_dir) and
        os.path.exists(public_keys_dir) and
        os.path.exists(secret_keys_dir)):
    print("Certificates are missing: run generate_certificates.py script first")
    sys.exit(1)

try:
    ctx = zmq.Context.instance()

    # Start an authenticator for this context.
    auth = ThreadAuthenticator(ctx)
    auth.start()
    auth.allow(endpoint_ip)
    # Tell the authenticator how to handle CURVE requests
    auth.configure_curve(domain='*', location=zmq.auth.CURVE_ALLOW_ANY)

    server = ctx.socket(zmq.REP)
    server_secret_file = os.path.join(secret_keys_dir, "server.key_secret")
    server_public, server_secret = zmq.auth.load_certificate(server_secret_file)
    server.curve_secretkey = server_secret
    server.curve_publickey = server_public
    server.curve_server = True  # must come before bind
    server.bind(endpoint)

    poller = zmq.Poller()
    poller.register(server, zmq.POLLIN)

except:
    print("creating zmq context/authentication failed")

mydb = mysql.connector.connect(
    host="localhost",
    user="root",
    passwd="root",
    database="mydatabase"
)

mycursor = mydb.cursor()

#mycursor.execute("CREATE DATABASE mydatabase")

mycursor.execute("SHOW DATABASES")
for x in mycursor:
  print(x)
mycursor.execute("CREATE TABLE IF NOT EXISTS `mydatabase`.`Sensors` ("
                 "`id` INT NOT NULL AUTO_INCREMENT,"
                 "`serial_num` INT NULL,"
                 "`systolic_pres` INT NULL,"
                 "`diastolic_pres` INT NULL,"
                 "`time` DATETIME NULL,"
                 "PRIMARY KEY (`id`))")
mycursor.execute("SHOW TABLES")
for x in mycursor:
  print(x)


try:
    while True:
        try:
            socks = dict(poller.poll(2500))  # POLL socket for 2000ms
        except KeyboardInterrupt:
            break;
        got_msg = False
        if server in socks:
            try:
                msg = server.recv_json() # socket reading
                got_msg = True
            except:
                print("error reading message")

        if got_msg:
            # printing all the values from one received json
            last_received = 0
            for m in msg['measurements']:
                print('Sensor Serial: ', m['serial_num'])
                print('Measured Systolic Pressure: %d Hgmm'
                      % m['systolic_pres'])
                print('Measured Diastolic Pressure: %d Hgmm'
                      % m['diastolic_pres'])
                print('Timestamp: ', m['time'])
                print('position in buffer: ', m['buffer_pos'])

                try:
                    sql = "INSERT INTO Sensors (serial_num, systolic_pres, diastolic_pres, time)" \
                          "VALUES (%s, %s, %s, %s)"
                    val = (m['serial_num'], m['systolic_pres'], m['diastolic_pres'], m['time'])
                    mycursor.execute(sql, val)
                    mydb.commit()
                    print(">Measurement saved successfully!")

                    last_received = m['buffer_pos']
                except:
                    last_received = 0
                    print(">Error saving measurement")
                print('')

            #nyugtázás vagy 0-ás hibajel küldés (=sikertelen mysql művelet)
            server.send(b'%d' % last_received)

        else:
            print("no message received in this turn")


except KeyboardInterrupt:
    print('Stopping client...')
    # stop auth thread
    mydb.close()
    auth.stop()
